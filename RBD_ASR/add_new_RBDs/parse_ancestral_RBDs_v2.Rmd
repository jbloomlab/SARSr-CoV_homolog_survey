---
title: "Parse ancestral RBDs"
author: "Tyler Starr"
date: "7/9/2020"
output:
  github_document:
    toc: true
    html_preview: false
editor_options: 
  chunk_output_type: inline
---

Want to check out some ancestors after incorporating three newly described sarbecovirus RBDs.

```{r setup, message=FALSE, warning=FALSE, error=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = T)
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))

#list of packages to install/load
packages = c("yaml","data.table","tidyverse")
#install any packages not already installed
installed_packages <- packages %in% rownames(installed.packages())
if(any(installed_packages == F)){
  install.packages(packages[!installed_packages])
}
#load packages
invisible(lapply(packages, library, character.only=T))

#read in file giving concordance between RBD numbering and SARS-CoV-2 Spike numbering, along with other possibly interesting annotations
RBD_sites <- read.csv(file="../../data/RBD_sites.csv",stringsAsFactors=F)

#make output directory
if(!file.exists("./parsed_sequences")){
 dir.create(file.path("./parsed_sequences"))
}
```

Session info for reproducing environment:
```{r print_sessionInfo}
sessionInfo()
```

## ASR on the ML phylogeny

We'll start by generating the best ancestral reconstructions at nodes of interest on the ML phylogeny. We read in the tables giving the posterior probabilities of each amino acid at each internal node on the phylogeny, and a table that gives the probability that a residue is a deletion at each node on the phylogeny given the indel modeling performed by FastML.



```{r input-ML-phylogeny-reconstruction}
PP_ML <- data.table(read.csv(file="ASR_v2/prob.marginal.csv"))
indels_ML <- read.table(file="ASR_v2/IndelsMarginalProb.txt",sep="\t",header=T)

#let's add the indels category as a column in PP_ML
for(i in 1:nrow(PP_ML)){
  if(PP_ML$Pos[i] %in% indels_ML$Pos){
    PP_ML$gap[i] <- indels_ML[indels_ML$Pos==PP_ML$Pos[i] & indels_ML$Node==PP_ML$Ancestral.Node[i],"Prob_Of_Indel"]
  }else{
    PP_ML$gap[i] <- 0
  }
}

#recalibrate PP in amino acid states incorporating the probability of a gap character -- that is, such that rowSum is always 1
for(i in 1:nrow(PP_ML)){
  PP_ML[i,c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y")] <- PP_ML[i,c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y")]*(1-PP_ML[i,gap])
}

```

We want ancestral sequences for the ancestral sarbecovirus, the ancestral Asian sarbecoviurs, and the ancestor of the SARS-CoV-2 clade -- as the main sequence inclusions were two new sequences within the SARS-CoV-2 clade itself, and one RBD highly similar to RmYN02 which is the less interesting 'deletions clade'. A table giving these node labels, shorthand names, and some "Notes" information is given in the file `ancestors_input.csv`. We load that table in, and append the MAP sequence, along with some statistics about average statistical support for ancestral states, and a list of ambiguously reconstructed states (PP < 0.8), and the plausible alternative states (PP > 0.2) at that node.

```{r get-MAP-ancestors}
ancestors <- read.csv(file="./ancestors_input.csv")

get.MAP <- function(node, table,altall=T){
  dt <- table[Ancestral.Node==node,]
  seq <- vector(mode="character",length=nrow(dt))
  PP.MAP <- vector(mode="numeric",length=nrow(dt))
  ambig.states <- vector(mode="character")
  alt.states <- vector(mode="character")
  if(altall==T){
    altall.seq <- vector(mode="character",length=nrow(dt))
  }
  for(i in dt$Pos){
    MAP.state <- c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y","gap")[which(dt[i,c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y","gap")]==max(dt[i,c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y","gap")]))]
    if(MAP.state=="gap"){seq[i] <- "-"}else{seq[i] <- MAP.state}
    if(altall==T){
      altall.seq[i] <- seq[i]
    }
    PP.MAP[i] <- dt[i,get(MAP.state)]
    if(PP.MAP[i] < 0.8){
      ambig.states <- c(ambig.states,paste(MAP.state,i,sep=""))
      for(aa in c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y","gap")){
        if(aa != MAP.state){
          if(dt[i,get(aa)]>0.2){
            alt.states <- c(alt.states,paste(aa,i,sep=""))
          }
        }
      }
      if(altall==T){
        aas <- c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y","gap")[c("A","C","D","E","F","G","H","I","K","L","M","N","P","Q","R","S","T","V","W","Y","gap") != MAP.state]
        if(max(dt[i,..aas]) >= 0.2){
          altall.state <- aas[which(dt[i,..aas]==max(dt[i,..aas]))]
          if(altall.state=="gap"){altall.seq[i] <- "-"}else{altall.seq[i] <- altall.state}
        }
      }
    }
  }
  if(altall==T){
    if(sum(altall.seq != seq)>0){
      return(list(list(seq),list(PP.MAP),list(ambig.states),list(alt.states),list(altall.seq)))
    }else{
      return(list(list(seq),list(PP.MAP),list(ambig.states),list(alt.states),list(NA)))
    }
  }else{
    return(list(list(seq),list(PP.MAP),list(ambig.states),list(alt.states)))
  }
}

for(i in 1:nrow(ancestors)){
  ancestors[i,c("MAP_seq","MAP_PP","ambig_states","alt_states","altALL_seq")] <- get.MAP(node=ancestors[i,"node"],table=PP_ML)
}

```

Let's enumerate the substitutions that link each (MAP) ancestral sequence to its prior ancestor, as that can be helpful to have listed out.

```{r enumerate_substitutions}
#function that compares two sequences and outputs differences
enumerate_subs <- function(seq1, seq2, SARS2_numbering=F){
  diffs <- vector(mode="character")
  for(i in 1:length(seq1)){
    if(seq1[i] != seq2[i]){
      if(SARS2_numbering==T){
        diffs <- c(diffs,paste(seq1[i],RBD_sites[RBD_sites$site_alignment==i,"site_SARS2"],seq2[i],sep=""))
      }else{
        diffs <- c(diffs,paste(seq1[i],i,seq2[i],sep=""))
      }
      
    }
  }
  if(length(diffs)>0){return(paste(diffs,collapse=";"))}else{return("")}
}

#need to manually do for each node since ancestors are not always directly above one another in the table
ancestors[ancestors$node=="N2","subs_alignpos"] <- ""
ancestors[ancestors$node=="N2","subs_SARS2pos"] <- ""

ancestors[ancestors$node=="N6","subs_alignpos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N2","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N6","MAP_seq"][[1]])
ancestors[ancestors$node=="N6","subs_SARS2pos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N2","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N6","MAP_seq"][[1]],SARS2_numbering=T)

ancestors[ancestors$node=="N52","subs_alignpos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N6","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N52","MAP_seq"][[1]])
ancestors[ancestors$node=="N52","subs_SARS2pos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N6","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N52","MAP_seq"][[1]],SARS2_numbering=T)

ancestors[ancestors$node=="N53","subs_alignpos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N52","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N53","MAP_seq"][[1]])
ancestors[ancestors$node=="N53","subs_SARS2pos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N52","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N53","MAP_seq"][[1]],SARS2_numbering=T)

ancestors[ancestors$node=="N54","subs_alignpos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N53","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N54","MAP_seq"][[1]])
ancestors[ancestors$node=="N54","subs_SARS2pos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N53","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N54","MAP_seq"][[1]],SARS2_numbering=T)

ancestors[ancestors$node=="N55","subs_alignpos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N54","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N55","MAP_seq"][[1]])
ancestors[ancestors$node=="N55","subs_SARS2pos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N54","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N55","MAP_seq"][[1]],SARS2_numbering=T)

ancestors[ancestors$node=="N56","subs_alignpos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N55","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N56","MAP_seq"][[1]])
ancestors[ancestors$node=="N56","subs_SARS2pos"] <- enumerate_subs(seq1=ancestors[ancestors$node=="N55","MAP_seq"][[1]],seq2=ancestors[ancestors$node=="N56","MAP_seq"][[1]],SARS2_numbering=T)

```

The ancestors table is useful if doing anything comparative in `R` because it keeps sequence strings split. However, for compiling sequences, manual browsing of csv, etc., easiest to collapse some information into a better output.

```{r output_ancestors}
ancestors_out <- subset(ancestors,select = c(node,name,notes,subs_alignpos,subs_SARS2pos))
for(i in 1:nrow(ancestors_out)){
  ancestors_out$MAP_seq[i] <- paste(ancestors$MAP_seq[i][[1]],collapse="")
  ancestors_out$MAP_PP[i] <- mean(ancestors$MAP_PP[i][[1]])
  ancestors_out$ambig_states[i] <- paste(ancestors$ambig_states[i][[1]],collapse=";")
  ancestors_out$alt_states[i] <- paste(ancestors$alt_states[i][[1]],collapse=";")
  ancestors_out$altALL_seq[i] <- paste(ancestors$altALL_seq[i][[1]],collapse="")
  ancestors_out$tree1_seq[i] <- paste(ancestors$tree1_seq[i][[1]],collapse="")
  ancestors_out$tree2_seq[i] <- paste(ancestors$tree2_seq[i][[1]],collapse="")
}
write.csv(ancestors_out,file="./parsed_sequences/ancestors_v2_table_collapsed.csv", quote=F, row.names=F)


```

Utility code to output differences between sequences

```{r diffs_anc_extant}
#example: differences between "v1" AncSarbecovirus and "v2" AncSarbecovirus
enumerate_subs(seq1=strsplit("NITNLCPFGEVFNATSFPSVYAWERMRISNCVADYSVLYNSSSSFSTFKCYGVSPTKLNDLCFSSVYADYFVVKGDDVRQIAPAQTGVIADYNYKLPDDFTGCVIAWNTNSLDSSS--GNNFFYRLFRHGKIKPYERDISNVLYNPAGGTCSSIEGLNCYKPLKSYGFTPTSGVGYQPYRVVVLSFELLNAPATVCGPKQST",split="")[[1]],
               seq2=strsplit("NITNLCPFGEVFNATSFPSVYAWERMRISNCVADYSVLYNSSSSFSTFKCYGVSPTKLNDLCFSSVYADYFVVKGDDVRQIAPAQTGVIADYNYKLPDDFTGCVLAWNTNSLDSSS--GNNFYYRLFRHGKIKPYERDISNVLYNPAGGTCSSIEGLNCYEPLKSYGFTPTAGVGYQPYRVVVLSFELLNAPATVCGPKQST",split="")[[1]],
               SARS2_numbering=T)

#between "v1" and "v2" AncAsia
enumerate_subs(seq1=strsplit("NITNLCPFGEVFNATTFPSVYAWERKRISNCVADYSVLYNST-SFSTFKCYGVSPTKLNDLCFSNVYADSFVVKGDDVRQIAPGQTGVIADYNYKLPDDFTGCVIAWNTNNLDSSSSGNYNYLYRLFRHSKLKPFERDISNEIYSPGGQPCSGVEGFNCYYPLQSYGFHPTTGVGYQPYRVVVLSFELLNAPATVCGPKLST",split="")[[1]],
               seq2=strsplit("NITNLCPFGEVFNATTFPSVYAWERKRISNCVADYSVLYNST-SFSTFKCYGVSPTKLNDLCFSSVYADSFVVKGDDVRQIAPGQTGVIADYNYKLPDDFTGCVLAWNTNNQDSSSSGNYNYYYRLFRHSKLKPFERDISNEIYSPGGQPCSSVEGFNCYYPLKSYGFYPTAGVGYQPYRVVVLSFELLNAPATVCGPKLST",split="")[[1]],
               SARS2_numbering=T)

#between "v1" and "v2" AncSARS2a
enumerate_subs(seq1=strsplit("NITNLCPFGEVFNATTFASVYAWNRKRISNCVADYSVLYNST-SFSTFKCYGVSPTKLNDLCFTNVYADSFVVKGDEVRQIAPGQTGVIADYNYKLPDDFTGCVIAWNSNNLDSKTGGNYNYLYRLFRKSKLKPFERDISTEIYQAGSTPCNGVEGFNCYYPLQSYGFHPTTGVGYQPYRVVVLSFELLNAPATVCGPKLST",split="")[[1]],
               seq2=strsplit("NITNLCPFGEVFNATTFASVYAWNRKRISNCVADYSVLYNST-SFSTFKCYGVSPTKLNDLCFTNVYADSFVVKGDEVRQIAPGQTGVIADYNYKLPDDFTGCVIAWNSNNQDASTSGNYNYYYRLFRKSKLKPFERDISNEIYQAGSQPCSSVEGFNCYYPLKSYGFYPTAGVGYQPYRVVVLSFELLNAPATVCGPKLST",split="")[[1]],
               SARS2_numbering=T)

```
